Прелюдия

Добро пожаловать в онлайн-руководство Google по Python. Он основан на вводном курсе Python, предлагаемом внутри компании. Как упоминалось на странице настройки , этот материал охватывает Python 3.

Если вам нужен сопутствующий курс MOOC, попробуйте курсы от Udacity и Coursera ( введение в программирование [для начинающих] или введение в Python ). Наконец, если вы ищете онлайн-обучение для самостоятельного обучения без просмотра видео, попробуйте те, которые перечислены в конце этого поста — каждый из них содержит обучающий контент, а также интерактивный интерпретатор Python, с которым вы можете практиковаться. Что это за «переводчик», о котором мы упоминаем? Вы узнаете в следующем разделе!

Введение в язык

Python — это динамический интерпретируемый (компилируемый байт-кодом) язык. В исходном коде нет объявлений типов переменных, параметров, функций или методов. Это делает код коротким и гибким, и вы теряете проверку типа исходного кода во время компиляции. Python отслеживает типы всех значений во время выполнения и помечает код, который не имеет смысла во время выполнения.

Отличный способ увидеть, как работает код Python, — запустить интерпретатор Python и ввести код прямо в него. Если у вас когда-нибудь возникнет вопрос типа «Что произойдет, если я добавлю int в list ?» Просто ввести его в интерпретатор Python — это быстрый и, вероятно, лучший способ увидеть, что произойдет. (Что происходит на самом деле, смотрите ниже!)

$ python3 ## Run the Python interpreter Python 3. X . X ( XXX , XXX XX XXXX , XX : XX : XX ) [ XXX ] on XXX Type "help" , "copyright" , "credits" or "license" for more information . >>> a = 6 ## set a variable in this interpreter session >>> a ## entering an expression prints its value 6 >>> a + 2 8 >>> a = 'hi' ## 'a' can hold a string just as well >>> a 'hi' >>> len ( a ) ## call the len() function on a string 2 >>> a + len ( a ) ## try something that doesn't work Traceback ( most recent call last ): File " " , line 1 , in TypeError : can only concatenate str ( not "int" ) to str >>> a + str ( len ( a )) ## probably what you really wanted 'hi2' >>> foo ## try something else that doesn't work Traceback ( most recent call last ): File " " , line 1 , in NameError : name 'foo' is not defined >>> ^ D ## type CTRL-d to exit (CTRL-z in Windows/DOS terminal)

Две строки, которые python печатает после ввода python и перед приглашением >>>, сообщают вам о версии Python, которую вы используете, и о том, где она была создана. Если первое, что напечатано, — это «Python 3», эти примеры вам подойдут.

Как вы можете видеть выше, с переменными и операторами легко экспериментировать. Кроме того, интерпретатор выдает или «вызывает» на языке Python ошибку времени выполнения, если код пытается прочитать переменную, которой не было присвоено значение. Подобно C++ и Java, Python чувствителен к регистру, поэтому «a» и «A» — разные переменные. Конец строки отмечает конец оператора, поэтому, в отличие от C++ и Java, Python не требует точки с запятой в конце каждого оператора. Комментарии начинаются с символа «#» и продолжаются до конца строки.

Исходный код Python

Исходные файлы Python используют расширение «.py» и называются «модулями». С модулем Python hello.py самый простой способ запустить его — использовать команду оболочки «python hello.py Alice», которая вызывает интерпретатор Python для выполнения кода в hello.py , передавая ему аргумент командной строки «Alice». См. официальную страницу документации, где описаны все возможные варианты запуска Python из командной строки.

Вот очень простая программа hello.py (обратите внимание, что блоки кода разделяются строго с помощью отступов, а не фигурных скобок — подробнее об этом позже!):

#!/usr/bin/python3 # import modules used here -- sys is a very standard one import sys # Gather our code in a main() function def main (): print ( 'Hello there' , sys . argv [ 1 ]) # Command line args are in sys.argv[1], sys.argv[2] ... # sys.argv[0] is the script name itself and can be ignored # Standard boilerplate to call the main() function to begin # the program. if __name__ == '__main__' : main ()

Запуск этой программы из командной строки выглядит так:

$ python3 hello.py Guido Hello there Guido $ ./hello.py Alice ## without needing 'python3' first (Unix) Hello there Alice

Импорт, аргументы командной строки и len()

Самые внешние операторы в файле Python, или «модуле», выполняют однократную настройку — эти операторы выполняются сверху вниз при первом импорте модуля куда-либо, настраивая его переменные и функции. Модуль Python можно запустить напрямую (как указано выше python3 hello.py Bob ) или его можно импортировать и использовать каким-либо другим модулем. Когда файл Python запускается напрямую, специальной переменной «__name__» присваивается значение «__main__». Поэтому обычно используется шаблон if __name__ ==... показанный выше, для вызова функции main(), когда модуль запускается напрямую, но не когда модуль импортируется каким-либо другим модулем.

В стандартной программе Python список sys.argv стандартным образом содержит аргументы командной строки, где sys.argv[0] — это сама программа, sys.argv[1] — первый аргумент и т. д. Если вы знаете об argc или количестве аргументов, вы можете просто запросить это значение из Python с помощью len(sys.argv) , точно так же, как мы это делали в коде интерактивного интерпретатора выше при запросе длины строки. В общем, len() может сообщить вам длину строки, количество элементов в списках и кортежах (еще одна структура данных, подобная массиву), а также количество пар ключ-значение в словаре.

Пользовательские функции

Функции в Python определяются следующим образом:

# Defines a "repeat" function that takes 2 arguments. def repeat ( s , exclaim ): """ Returns the string 's' repeated 3 times. If exclaim is true, add exclamation marks. """ result = s + s + s # can also use "s * 3" which is faster (Why?) if exclaim : result = result + '!!!' return result

Обратите также внимание на то, как строки, составляющие функцию или оператор if, группируются, имея одинаковый уровень отступов. Мы также представили 2 различных способа повторения строк, используя оператор +, который более удобен для пользователя, но * также работает, потому что это оператор повторения Python, что означает, что '-' * 10 дает '----------' , удобный способ создать экранную «линию». В комментарии к коду мы намекнули, что * работает быстрее, чем +, причина в том, что * вычисляет размер результирующего объекта один раз, тогда как при использовании + этот расчет выполняется каждый раз при вызове +. И +, и * называются «перегруженными» операторами, поскольку они означают разные вещи для чисел и строк (и других типов данных).

Ключевое слово def определяет функцию с ее параметрами в круглых скобках и с отступом в коде. Первой строкой функции может быть строка документации («строка документации»), описывающая, что делает функция. Строка документации может представлять собой одну строку или многострочное описание, как в примере выше. (Да, это «тройные кавычки», уникальная особенность Python!) Переменные, определенные в функции, являются локальными для этой функции, поэтому «результат» в приведенной выше функции отделен от переменной «результат» в другой функции. Оператор return может принимать аргумент, и в этом случае это значение, возвращаемое вызывающей стороне.

Вот код, который вызывает указанную выше функцию повторения() и печатает то, что она возвращает:

def main (): print ( repeat ( 'Yay' , False )) ## YayYayYay print ( repeat ( 'Woo Hoo' , True )) ## Woo HooWoo HooWoo Hoo!!!

Во время выполнения функции должны быть определены путем выполнения «def» перед их вызовом. Обычно функцию main() определяют в нижней части файла, а функции, которые она вызывает, — над ней.

Отступ

Одна необычная особенность Python заключается в том, что отступы в виде пробелов в фрагменте кода влияют на его смысл. Логический блок операторов, таких как те, которые составляют функцию, должен иметь одинаковый отступ, установленный на основе отступа родительской функции, «if» или чего-то еще. Если одна из строк в группе имеет другой отступ, это помечается как синтаксическая ошибка.

Использование пробелов в Python поначалу кажется немного странным, но это логично, и я обнаружил, что очень быстро к этому привык. Избегайте использования TAB, поскольку они сильно усложняют схему отступов (не говоря уже о том, что TAB могут означать разные вещи на разных платформах). Настройте свой редактор на вставку пробелов вместо табуляции для кода Python.

Частый вопрос, который задают новички: «Сколько пробелов мне следует сделать отступ?» Согласно официальному руководству по стилю Python (PEP 8) , отступ должен составлять 4 пробела. (Забавный факт: внутренние правила Google по стилю требуют отступа в 2 пробела!)

Код проверяется во время выполнения

Python выполняет очень мало проверок во время компиляции, откладывая почти все проверки типа, имени и т. д. в каждой строке до тех пор, пока эта строка не будет запущена. Предположим, что приведенная выше функция main() вызывает функцию повторения следующим образом:

def main (): if name == 'Guido' : print ( repeeeet ( name ) + '!!!' ) else : print ( repeat ( name ))

В операторе if содержится очевидная ошибка: функция повторения() случайно введена как повторение(). Самое забавное в Python... этот код компилируется и работает нормально, пока имя во время выполнения не «Guido». Только когда запуск действительно попытается выполнить repeeeet(), он заметит, что такой функции нет, и выдаст ошибку. В этом фрагменте также есть вторая ошибка. имени не было присвоено значение до его сравнения с «Guido». Python выдаст ошибку NameError, если вы попытаетесь оценить неназначенную переменную. Вот несколько примеров, демонстрирующих, что при первом запуске программы на Python одними из первых ошибок, которые вы увидите, будут простые опечатки или подобные неинициализированные переменные. Это одна из областей, где языки с более подробной системой типов, такие как Java, имеют преимущество... они могут обнаруживать такие ошибки во время компиляции (но, конечно, вам нужно поддерживать всю эту информацию о типах... это компромисс).

В Python 3 появились подсказки типов . Подсказки типов позволяют указать тип каждого аргумента функции, а также тип объекта, возвращаемого функцией. Например, в аннотированной функции def is_positive(n: int) -> bool: аргумент n — это int , а возвращаемое значение — bool . Позже мы разберемся, что означают эти типы. Однако подсказки типов совершенно необязательны. Вы увидите все больше и больше кодов, использующих подсказки по типам, потому что если вы их используете, некоторые редакторы, такие как cider-v и VS.code, могут запускать проверки, чтобы убедиться, что ваши функции вызываются с правильными типами аргументов. Они могут даже предлагать и проверять аргументы при редактировании кода. В этом руководстве не рассматриваются подсказки по типам, но мы хотим убедиться, что вы знаете о них, если услышите о них или увидите их в реальной жизни.

Имена переменных

Поскольку в исходном коде переменных Python не указан какой-либо тип, очень полезно давать переменным осмысленные имена, чтобы напоминать себе о том, что происходит. Поэтому используйте «имя», если это одно имя, «имена», если это список имен, и «кортежи», если это список кортежей. Многие основные ошибки Python возникают из-за того, что вы забываете, какой тип значения находится в каждой переменной, поэтому используйте имена переменных (все, что у вас есть на самом деле), чтобы все было ясно.

Что касается фактического именования, некоторые языки предпочитают underscored_parts для имен переменных, состоящих из «более одного слова», но другие языки предпочитают верблюжий регистр. В целом Python предпочитает метод подчеркивания, но рекомендует разработчикам использовать CamelCasing при интеграции в существующий код Python, который уже использует этот стиль. Читабельность имеет значение. Подробнее читайте в разделе о соглашениях об именах в PEP 8 .

Как вы можете догадаться, такие ключевые слова, как if и while, нельзя использовать в качестве имен переменных — если вы это сделаете, вы получите синтаксическую ошибку. Однако будьте осторожны и не используйте встроенные модули в качестве имен переменных. Например, хотя «str», «list» и «print» могут показаться хорошими именами, вы будете переопределять эти системные переменные. Встроенные модули не являются ключевыми словами и поэтому могут быть случайно использованы новыми разработчиками Python.

Подробнее о модулях и их пространствах имен

Предположим, у вас есть модуль «binky.py», который содержит «def foo()». Полное имя этой функции foo — «binky.foo». Таким образом, различные модули Python могут называть свои функции и переменные по своему усмотрению, и имена переменных не будут конфликтовать — модуль1.foo отличается от модуля2.foo. В словаре Python мы бы сказали, что Binky, Module1 и Module2 имеют свои собственные «пространства имен», которые, как вы можете догадаться, представляют собой привязки имени переменной к объекту.

Например, у нас есть стандартный модуль «sys», который содержит некоторые стандартные системные возможности, такие как список argv и функцию exit(). С помощью оператора «import sys» вы можете получить доступ к определениям в модуле sys и сделать их доступными по полному имени, например sys.exit(). (Да, у «sys» тоже есть пространство имен!)

import sys # Now can refer to sys.xxx facilities sys . exit ( 0 )

Есть еще одна форма импорта, которая выглядит так: «from sys import argv, выход». Это делает argv и exit() доступными по их коротким именам; однако мы рекомендуем исходную форму с полными именами, поскольку так намного проще определить, откуда взялась функция или атрибут.

В стандартную установку интерпретатора Python входит множество модулей и пакетов, поэтому для их использования не нужно делать ничего дополнительного. Все вместе они известны как «Стандартная библиотека Python». Обычно используемые модули/пакеты включают:

sys — доступ к выходам(), argv, stdin, stdout, ...

re — регулярные выражения

os — интерфейс операционной системы, файловая система

Вы можете найти документацию по всем модулям и пакетам стандартной библиотеки по адресу http://docs.python.org/library .

Онлайн-справка, help() и dir()

Существует множество способов получить помощь по Python.

Выполните поиск в Google, начиная со слова «python», например «список Python» или «строка Python в нижнем регистре». Часто ответом оказывается первое попадание. По какой-то причине этот метод работает лучше для Python, чем для других языков.

Официальный сайт документации Python — docs.python.org — содержит высококачественную документацию. Тем не менее, я часто считаю, что поиск по паре слов в Google выполняется быстрее.

Существует также официальный список рассылки Tutor, специально предназначенный для новичков в Python и/или программировании!

Множество вопросов (и ответов) можно найти на StackOverflow и Quora .

Используйте функции help() и dir() (см. ниже).

Внутри интерпретатора Python функция help() извлекает строки документации для различных модулей, функций и методов. Эти строки документа аналогичны Javadoc. Функция dir() сообщает вам, каковы атрибуты объекта. Ниже приведены некоторые способы вызова help() и dir() из интерпретатора: